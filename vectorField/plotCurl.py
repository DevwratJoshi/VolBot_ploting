import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy import interpolate
import math
from matplotlib.colors import BoundaryNorm
from matplotlib.ticker import MaxNLocator
X = "PIV_X" # The beginning of the X file
Y = "PIV_Y" # The beginning of the Y file
no = "100" # The number of robots
box_bottom = "900"
freq = "20"
amp = "8"
up = "5"
down = "2"
s = "_" # The seperator between the above in the file name
url = "/home/dev/sketchbookProcessing/BNEpaperSims/VolBot_Flow/PIV_data_constant_top/middle/sections_max20/"
extention = ""
dataX = pd.read_csv(url + "X" + "/" + "bottom" + down +  extention, header=None, usecols = [i for i in range(20)])
dataY = pd.read_csv(url + "Y" + "/" + "bottom" + down +  extention, header=None, usecols = [i for i in range(20)])
#print(data.values[0][0]) # This gives us the [][]th value 

#Remember that data for velocity at (x,y) is stored at data.values[y][x]
#Flip the array using np.flipud
def makeColourTuple(*ctup): #Makes a colour tuple using rgb values out of 255
    return tuple([round(float(i/255.0), 2) if i < 255 else 255.0 for i in ctup])


trueX = np.copy(dataX.values)
trueX = np.flipud(trueX)
trueY = np.copy(dataY.values)
trueY = np.flipud(trueY)
x,y = np.meshgrid(np.linspace(0.5, 19.5, 20), np.linspace(0.5, 19.5, 20))
trueX_norm = np.copy(trueX)
trueY_norm = np.copy(trueY)
for i in range(trueX.shape[0]):
     for j in range(trueX.shape[1]):
             a = trueX[i][j]
             b = trueY[i][j]
             trueX_norm[i][j] = trueX[i][j]/math.sqrt(a**2 + b**2)
             trueY_norm[i][j] = trueY[i][j]/math.sqrt(a**2 + b**2)

#Now to calculate the curl
# f describes the x component and g describes the y component of the vector at (x,y) of the continuous vector field f(x,y)i + g(x,y)j
f = interpolate.RectBivariateSpline(np.linspace(1, 20, 20), np.linspace(1, 20, 20), trueX) 
g = interpolate.RectBivariateSpline(np.linspace(1, 20, 20), np.linspace(1, 20, 20), trueY)


fig, ax = plt.subplots(1,1)
#ax.scatter(x, y, s=2)
# The following is to test if the discrete quiver plot generated by the interpolation creates the same quiver plot as the original data
#Start checking if the plot is the same
tempx, tempy = np.meshgrid(np.linspace(1, 20, 39),  np.linspace(1, 20, 39))
fd = np.zeros(tempx.shape)
gd = np.zeros(tempy.shape)

#The indices in the following have a close relationship with the shape of tempx, tempy. i.e. the number of elements I wanted to plot. Leave the values alone
for i in range(40):
    for j in range(40):
             fd[i-1][j-1] = f(i/2.0,j/2.0)
             gd[i-1][j-1] = g(i/2.0,j/2.0)
#ax.quiver(tempx,tempy,fd, gd, pivot='mid', color='blue')
# End of checking if the plot is the same

#Now for the curl
#the formula is f_y - g_x
h = 1 # This will be the delta x or delta y value while calculating the integral
der = np.zeros((50, 50))

#for i in range(der.shape[0]):
#    for j in range(der.shape[1]):
#        #der[i][j] = -1*((f(i, ((j*20/der.shape[0]) + h)) - f(i, (j*20/der.shape[0])))/h) - ((g(((i*20/der.shape[0]) + h), j) - g((i*20/der.shape[0]), j))/h)
#        der[i][j] = -((f(i, j+h) - f(i, j))/h) + ((g(i+h, j) - g(i, j))/h)

for i in range(trueX.shape[0]-1):
    for j in range(trueX.shape[1]-1):
        #der[i][j] = -1*((f(i, ((j*20/der.shape[0]) + h)) - f(i, (j*20/der.shape[0])))/h) - ((g(((i*20/der.shape[0]) + h), j) - g((i*20/der.shape[0]), j))/h)
        der[i][j] = -1*(f(i, j + h) - f(i, j))/h - (g(i + h, j) - g(i, j))/h
        #der[i][j] = -((trueX[i][j+1] - trueX[i][j])/h) + ((trueY[i+1][j] - trueY[i][j])/h)

derX, derY = np.meshgrid(np.linspace(0, 20, der.shape[0] - 1), np.linspace(1, 20, der.shape[0] - 1))        
der = der[:-1, :-1]
levels = MaxNLocator(nbins='auto').tick_values(der.min(), der.max())
cmap = plt.get_cmap('RdBu')
norm = BoundaryNorm(levels, ncolors=cmap.N, clip=True)
im = ax.pcolormesh(derX, derY, der, cmap=cmap, norm=norm)
fig.colorbar(im, ax=ax)

ax.quiver(x,y,trueX_norm, trueY_norm, pivot='mid')

ax.set_title("freq {} amp {} up {} down {}".format(freq, amp, up, down))
ax.set_xlabel("X position")
ax.set_ylabel("Y position")
plt.xticks(np.arange(0, 20+1, 1))
plt.yticks(np.arange(0, 20+1, 1))

xu = float(up) *(20.0/(10.0))
yu = 20
xd = float(down)*(20.0/10.0)
yd = 0



plt.plot([xu, xd], [yu, yd], color=(makeColourTuple(112, 48, 160)), linewidth=2)
plt.show()
